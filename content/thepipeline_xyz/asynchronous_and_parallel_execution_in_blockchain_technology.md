---
title: Asynchronous and Parallel Execution in Blockchain Technology
videoId: hXxU3epZw9E
---

From: [[thepipeline_xyz]] <br/> 

Monad is an EVM L1 equivalent blockchain that represents a fundamental redesign of existing blockchain architectures. It aims to provide a high-performance system while maintaining full EVM compatibility and decentralization <a class="yt-timestamp" data-t="00:22:00">[00:22:00]</a>. This is achieved through its unique approach to [[asynchronous_execution_in_blockchain | asynchronous execution]], [[parallel_execution_in_blockchain_technology | parallel execution]], and a custom state database called MonadDB <a class="yt-timestamp" data-t="00:48:47">[00:48:47]</a>.

## Monad: A High-Performance EVM L1

From a developer's perspective, Monad feels familiar to anyone who has developed on an EVM, offering full EVM L1 equivalence and RPC compatibility <a class="yt-timestamp" data-t="00:30:00">[00:30:00]</a><a class="yt-timestamp" data-t="00:35:00">[00:35:00]</a><a class="yt-timestamp" data-t="00:01:02">[00:01:02]</a>. It allows developers to tap into a high-performance system capable of 10,000 real Ethereum transactions per second <a class="yt-timestamp" data-t="00:39:00">[00:39:00]</a><a class="yt-timestamp" data-t="00:45:00">[00:45:00]</a><a class="yt-timestamp" data-t="00:52:00">[00:52:00]</a>, with single block times and single slot finality <a class="yt-timestamp" data-t="00:58:00">[00:58:00]</a>.

For users, Monad provides a high-performance, low-cost system where Ethereum applications can thrive <a class="yt-timestamp" data-t="00:01:26">[00:01:26]</a><a class="yt-timestamp" data-t="00:01:30">[00:01:30]</a>. Transaction costs are significantly reduced (e.g., hundreds of a cent for a Uniswap V2 transaction) <a class="yt-timestamp" data-t="00:01:33">[00:01:33]</a>, and decentralization is maintained through hundreds of globally distributed nodes with reasonable hardware requirements <a class="yt-timestamp" data-t="00:01:36">[00:01:36]</a><a class="yt-timestamp" data-t="00:01:39">[00:01:39]</a>.

## Addressing Blockchain Bottlenecks

Traditional distributed systems and blockchains face four fundamental constraints:
*   **Network Bandwidth:** Internet overhead <a class="yt-timestamp" data-t="00:02:24">[00:02:24]</a>.
*   **CPU Throughput:** Speed of computer cores <a class="yt-timestamp" data-t="00:02:28">[00:02:28]</a>.
*   **State Access:** Accessing the blockchain's historical state from the database <a class="yt-timestamp" data-t="00:02:33">[00:02:33]</a>.
*   **State Growth:** Managing current accounts and their balances <a class="yt-timestamp" data-t="00:02:38">[00:02:38]</a>.

Many blockchains try to overcome these by increasing bandwidth requirements (e.g., 1 GB or 10 GB connections vs. Monad's 100 MB/s target) <a class="yt-timestamp" data-t="00:03:00">[00:03:00]</a><a class="yt-timestamp" data-t="00:03:04">[00:03:04]</a>, co-locating nodes to reduce latency <a class="yt-timestamp" data-t="00:03:24">[00:03:24]</a>, or significantly increasing RAM requirements, which makes nodes very expensive <a class="yt-timestamp" data-t="00:03:39">[00:03:39]</a><a class="yt-timestamp" data-t="00:03:42">[00:03:42]</a>.

Monad's goal is to maximize [[optimizing_blockchain_performance | performance]] from commodity hardware by designing software that saturates hardware through these bottlenecks while preserving decentralization, meaning reasonable RAM requirements and a globally distributed network of hundreds of nodes <a class="yt-timestamp" data-t="00:04:02">[00:04:02]</a><a class="yt-timestamp" data-t="00:04:11">[00:04:11]</a><a class="yt-timestamp" data-t="00:04:14">[00:04:14]</a>. This is achieved through a new software architecture that fully redesigns consensus and the execution engine <a class="yt-timestamp" data-t="00:04:20">[00:04:20]</a><a class="yt-timestamp" data-t="00:04:32">[00:04:32]</a>.

## [[asynchronous_execution_in_blockchain | Asynchronous Execution]]

Most blockchains today use "interleaved execution," where execution and consensus occur in tandem within a single block time <a class="yt-timestamp" data-t="00:05:17">[00:05:17]</a><a class="yt-timestamp" data-t="00:05:29">[00:05:29]</a>. For example, in Ethereum's 12-second block time, execution might only take 1% of the time, while consensus takes significantly longer due to global network latency <a class="yt-timestamp" data-t="00:05:35">[00:05:35]</a><a class="yt-timestamp" data-t="00:05:54">[00:05:54]</a>.

[[asynchronous_execution_in_blockchain | Asynchronous execution]] stems from the realization that execution can be decoupled from consensus <a class="yt-timestamp" data-t="00:06:24">[00:06:24]</a><a class="yt-timestamp" data-t="00:06:28">[00:06:28]</a>. Since the EVM is a deterministic state machine, knowing the transaction ordering and data allows one to predict the outcome without immediate execution <a class="yt-timestamp" data-t="00:06:37">[00:06:37]</a><a class="yt-timestamp" data-t="00:06:43">[00:06:43]</a>.

Monad leverages this by executing the previous block in parallel with ordering the current block <a class="yt-timestamp" data-t="00:07:10">[00:07:10]</a><a class="yt-timestamp" data-t="00:07:13">[00:07:13]</a><a class="yt-timestamp" data-t="00:07:17">[00:07:17]</a>.This separation means consensus and execution operate on different sides of the block time, allowing execution to utilize the entire block time <a class="yt-timestamp" data-t="00:07:32">[00:07:32]</a><a class="yt-timestamp" data-t="00:08:11">[00:08:11]</a><a class="yt-timestamp" data-t="00:08:14">[00:08:14]</a>.

> "We are executing the previous block while coming to consensus on the ordering and the data in the current block." <a class="yt-timestamp" data-t="00:08:21">[00:08:21]</a>

This approach significantly expands the execution budget and, consequently, the gas budget, leading to higher [[the_importance_of_high_throughput_blockchains | throughput]] and lower fees <a class="yt-timestamp" data-t="00:08:29">[00:08:29]</a><a class="yt-timestamp" data-t="00:08:32">[00:08:32]</a><a class="yt-timestamp" data-t="00:08:36">[00:08:36]</a>. Nodes come to consensus on transaction ordering before execution <a class="yt-timestamp" data-t="00:08:52">[00:08:52]</a>. Even though blocks are executed later, finality is achieved at consensus time because the deterministic nature of the EVM ensures that the outcome is known once the data and order are agreed upon <a class="yt-timestamp" data-t="00:09:48">[00:09:48]</a><a class="yt-timestamp" data-t="00:09:55">[00:09:55]</a>. Many other blockchains, including Solana, are exploring similar [[asynchronous_execution_in_blockchain | asynchronous execution]] models <a class="yt-timestamp" data-t="00:09:26">[00:09:26]</a><a class="yt-timestamp" data-t="00:09:30">[00:09:30]</a>.

## [[parallel_execution_in_blockchain_technology | Parallel Execution]]

[[parallel_execution_in_blockchain_technology | Parallel execution]] is about utilizing the multiple cores found in modern computers to process transactions concurrently, effectively turning "one lane into multiple lanes" <a class="yt-timestamp" data-t="00:10:32">[00:10:32]</a><a class="yt-timestamp" data-t="00:10:37">[00:10:37]</a>. While transactions are typically linearly ordered and serially executed in most blockchains <a class="yt-timestamp" data-t="00:10:46">[00:10:46]</a>, Monad aims to maintain this consensus-given ordering but execute everything in parallel, committing the results in the original order <a class="yt-timestamp" data-t="00:10:59">[00:10:59]</a><a class="yt-timestamp" data-t="00:11:06">[00:11:06]</a>.

Monad employs an [[optimistic_parallel_execution_algorithm | optimistic parallel execution algorithm]], also known as Software Transactional Memory or Optimistic Concurrency Control (OCC) <a class="yt-timestamp" data-t="00:11:13">[00:11:13]</a><a class="yt-timestamp" data-t="00:11:17">[00:11:17]</a><a class="yt-timestamp" data-t="00:11:21">[00:11:21]</a>. The process works as follows:
1.  Assume everything can run in parallel and start with a synced view of the world <a class="yt-timestamp" data-t="00:11:28">[00:11:28]</a>.
2.  Generate pending results from parallel execution <a class="yt-timestamp" data-t="00:11:33">[00:11:33]</a>.
3.  Walk through the pending results in order, attempting to commit them <a class="yt-timestamp" data-t="00:11:39">[00:11:39]</a>.
4.  If a pending result relied on a previous one that changed, re-execute it with the new state <a class="yt-timestamp" data-t="00:11:43">[00:11:43]</a><a class="yt-timestamp" data-t="00:11:45">[00:11:45]</a>.

This algorithm ensures that a transaction never has to be re-executed more than once <a class="yt-timestamp" data-t="00:13:16">[00:13:16]</a><a class="yt-timestamp" data-t="00:13:20">[00:13:20]</a>. The overhead of re-execution is low because the system has already cached the necessary state, making execution itself very cheap compared to calling up state from the database <a class="yt-timestamp" data-t="00:13:23">[00:13:23]</a><a class="yt-timestamp" data-t="00:13:29">[00:13:29]</a><a class="yt-timestamp" data-t="00:13:41">[00:13:41]</a><a class="yt-timestamp" data-t="00:13:46">[00:13:46]</a>. A significant benefit of this model is that developers do not need to deal with access lists, which can add bandwidth overhead <a class="yt-timestamp" data-t="00:13:59">[00:13:59]</a><a class="yt-timestamp" data-t="00:14:03">[00:14:03]</a><a class="yt-timestamp" data-t="00:14:06">[00:14:06]</a>.

## MonadDB: Enabling Parallel State Access

MonadDB is a custom state database that is crucial for making [[parallel_execution_in_blockchain_technology | parallel execution]] truly effective <a class="yt-timestamp" data-t="00:14:29">[00:14:29]</a><a class="yt-timestamp" data-t="00:14:32">[00:14:32]</a>. It feeds the parallel execution engine by allowing parallel state access <a class="yt-timestamp" data-t="00:14:58">[00:14:58]</a><a class="yt-timestamp" data-t="00:15:01">[00:15:01]</a><a class="yt-timestamp" data-t="00:15:04">[00:15:04]</a>. Without parallel state access, the system would bottleneck waiting for the database to pull out dependencies for each transaction, negating the benefits of parallel execution <a class="yt-timestamp" data-t="00:15:07">[00:15:07]</a><a class="yt-timestamp" data-t="00:15:19">[00:15:19]</a>. Therefore, [[asynchronous_execution_in_blockchain | asynchronous]] I/O is essential to issue multiple requests to the database in parallel and quickly execute as results return <a class="yt-timestamp" data-t="00:15:25">[00:15:25]</a><a class="yt-timestamp" data-t="00:15:27">[00:15:27]</a><a class="yt-timestamp" data-t="00:15:32">[00:15:32]</a>.

Modern SSDs offer high bandwidth and millions of I/O operations per second, making it critical to saturate this memory bandwidth by pulling data out of state in parallel <a class="yt-timestamp" data-t="00:15:42">[00:15:42]</a><a class="yt-timestamp" data-t="00:15:53">[00:15:53]</a><a class="yt-timestamp" data-t="00:16:07">[00:16:07]</a><a class="yt-timestamp" data-t="00:16:09">[00:16:09]</a>.

Ethereum stores its state in a Merkel Patricia Trie (MPT), which is fundamental for succinct verification of transactions and state â€“ allowing efficient checking of data integrity via a root hash <a class="yt-timestamp" data-t="00:16:32">[00:16:32]</a><a class="yt-timestamp" data-t="00:17:15">[00:17:15]</a><a class="yt-timestamp" data-t="00:17:21">[00:17:21]</a><a class="yt-timestamp" data-t="00:17:26">[00:17:26]</a>. However, most existing Ethereum clients use off-the-shelf databases (like B-trees or LSM trees) to store this MPT <a class="yt-timestamp" data-t="00:16:44">[00:16:44]</a><a class="yt-timestamp" data-t="00:16:50">[00:16:50]</a><a class="yt-timestamp" data-t="00:17:00">[00:17:00]</a>. This creates an inefficiency: when transversing the logical MPT, the system performs a "tree traversal within a tree traversal" in the backend database, resulting in 16 to 32 times more overhead for each lookup <a class="yt-timestamp" data-t="00:19:18">[00:19:18]</a><a class="yt-timestamp" data-t="00:19:20">[00:19:20]</a><a class="yt-timestamp" data-t="00:19:36">[00:19:36]</a><a class="yt-timestamp" data-t="00:19:39">[00:19:39]</a>.

MonadDB is a complete rebuild of a database where the Merkle Patricia Trie is the *actual* way data is stored on disk <a class="yt-timestamp" data-t="00:19:42">[00:19:42]</a><a class="yt-timestamp" data-t="00:19:45">[00:19:45]</a><a class="yt-timestamp" data-t="00:19:47">[00:19:47]</a>. This removes the indirection, leading to 16 to 32 times fewer lookups per tree traversal <a class="yt-timestamp" data-t="00:19:50">[00:19:50]</a><a class="yt-timestamp" data-t="00:19:53">[00:19:53]</a><a class="yt-timestamp" data-t="00:20:10">[00:20:10]</a><a class="yt-timestamp" data-t="00:20:13">[00:20:13]</a>. Combined with [[asynchronous_execution_in_blockchain | asynchronous]] I/O using IOU ring kernel technology, MonadDB enables parallel state access <a class="yt-timestamp" data-t="00:20:19">[00:20:19]</a><a class="yt-timestamp" data-t="00:20:20">[00:20:20]</a><a class="yt-timestamp" data-t="00:20:58">[00:20:58]</a><a class="yt-timestamp" data-t="00:21:00">[00:21:00]</a><a class="yt-timestamp" data-t="00:21:14">[00:21:14]</a>. This is the "secret sauce" that allows Monad to fully saturate its [[parallel_execution_in_blockchain_technology | parallel execution]] engine by ensuring that compute is not bottlenecked waiting for data <a class="yt-timestamp" data-t="00:20:28">[00:20:28]</a><a class="yt-timestamp" data-t="00:20:30">[00:20:30]</a><a class="yt-timestamp" data-t="00:20:36">[00:20:36]</a><a class="yt-timestamp" data-t="00:21:19">[00:21:19]</a><a class="yt-timestamp" data-t="00:21:20">[00:21:20]</a>.

The combination of [[asynchronous_execution_in_blockchain | asynchronous execution]], [[parallel_execution_in_blockchain_technology | parallel execution]], and MonadDB's parallel state access is key to Monad's ability to achieve high [[performance_and_scalability_of_blockchain_systems | performance and scalability]] while preserving decentralization and EVM compatibility <a class="yt-timestamp" data-t="00:04:02">[00:04:02]</a><a class="yt-timestamp" data-t="00:04:11">[00:04:11]</a><a class="yt-timestamp" data-t="00:04:14">[00:04:14]</a>.